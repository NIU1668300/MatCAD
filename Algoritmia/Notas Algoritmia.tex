\documentclass[11pt]{article}
\RequirePackage{etex}
%\pagestyle{empty}
\usepackage[activeacute,spanish,american]{babel}
\usepackage[utf8]{inputenc}%Para usar los acentos normalmente.
\usepackage[T1]{fontenc}
% \usepackage[usenames,dvipsnames,svgnames]{xcolor}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{url}
\urlstyle{same}

\usepackage[makestderr]{pythontex}
% \restartpythontexsession{\thesection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

\usepackage{tkz-base}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage[most]{tcolorbox}
\usepackage{helvet, amssymb,amsmath,latexsym}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{textcomp}
\usepackage{multienum}
\usepackage[inline,shortlabels]{enumitem}
\usepackage{multicol}
\usepackage{float}
% \usepackage{gensymb}
\providecommand{\norm}[1]{\left\lVert #1 \right \rVert}
\providecommand{\abs}[1]{\left\lvert #1\right\rvert}
\usepackage{color,soul}%permite texto y subrayar en color.
\input{/home/samuel/Documents/Latex/Colores.tex}
% \usepackage[pdftex]{graphicx}
%Dimensiones
\usepackage[a4paper,left=2cm,right=1.5cm, top=1.5cm, bottom=3cm,includehead]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Nombres de conjuntos y comandos propios.
\providecommand{\norm}[1]{\left\lVert #1 \right \rVert}
\providecommand{\abs}[1]{\left\lvert #1\right\rvert}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\I}{\mathbb{I}}
% \usepackage{esvect}
% \renewcommand{\vec}{\vv}
 \usepackage{pgf,tikz}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shadows}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{shapes.multipart}
\usetikzlibrary{chains}
\usetikzlibrary{scopes}
\usetikzlibrary{matrix}
\usetikzlibrary{positioning,automata,calc}
 %\usepackage{framed}{}
 %\usepackage[framed, amsthm,thmmarks,thref]{ntheorem}
 %\usepackage{tkz-tab,tkz-euclide,tkz-fct,tkz-linknodes}
 \usepackage{tkz-tab,tkz-euclide}
 \usepackage{pythontex}
% \usetkzobj{all}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Cajas de colores
%
\input{/home/samuel/Documents/Latex/ColorBoxes}
\input{/home/samuel/Documents/Latex/Exercises}
%Ecuaciones resaltadas
% \usepackage[overload,ntheorem,reqno]{empheq}
%\input{/home/samuel/Documents/Latex/Ambientes-teoremas}
 \theoremstyle{plain}
 \renewcommand{\qedsymbol}{\makebox[7.7778pt][c]{\rule{1ex}{1ex}}}
 \newtheorem*{demo}{Demostración}
 \input{/home/samuel/Documents/Latex/TeoremasEnumerados}
\usepackage{hyperref}
\hypersetup{
    % bookmarks=false,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat?s bookmarks
    pdftoolbar=true,        % show Acrobat?s toolbar?
    pdfmenubar=true,        % show Acrobat?s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={Teoria de Algoritmia},    % title
    pdfauthor={Samuel Ortega Cuadra},     % author
    pdfsubject={},   % subject of the document
    pdfcreator={Hecho con \LaTeX},   % creator of the document
    pdfproducer={ps2pdf}, % producer of the document
    pdfkeywords={} {} {}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=naranja,          % color of internal links
    citecolor=violeta,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}


\setcounter{secnumdepth}{4} %controla la profundidad de la numeración

\addto\captionsamerican{%
  \renewcommand{\contentsname}%
    {Índice}%
}


\title{Notas Algoritmia}
\author{Samuel Ortega Cuadra}
\input{/home/samuel/Documents/Latex/messages}

\begin{document}
    \begin{center}
        \huge{Teoría de Algoritmia. 1º de Carrera. Tema 1}
    \end{center}
    \tableofcontents
    \newpage
    \section{Introducción} % (fold)
    \label{sec:introducción}
        Un grafo combinatorio es una pareja ordenada $G = (V,E)$ de V vértices y un subconjunto E contenido en $V \times V$ siendo este el producto Cartesiano $V \times V$. Si el grafo no está dirigido se llaman aristas y las parejas $(v,w) \in E$ se consideran sin orden. Si el grafo está dirigido u orientado los elementos de E se llaman flechas, las cuales poseen una dirección, y las parejas $(v,w)$ un orden. Si el grafo no está dirigido, no se considera que tenga un principio o un final, simplemente están relacionados.\\

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \tikzstyle{every node}=[draw,shape=circle];
                \node (A) at (3,0) {A};
                \node (B) at (1,-1) {B};
                \node (C) at (-1,-1) {C};
                \node (D) at (-1,1) {D};
                \node (E) at (1,1) {E};
                \node (F) at (-3,1) {F};
                \draw (F) -- (D);
                \draw (D) -- (E);
                \draw (E) -- (A);
                \draw (B) -- (A);
                \draw (E) -- (B);
                \draw (C) -- (D);
                \draw (C) -- (B);
            \end{tikzpicture}
            \caption{Grafo No Dirigido} \label{Fig_1}
        \end{figure}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}
                \tikzstyle{every node}=[draw,shape=circle];
                \node (A) at (-2,1) {A};
                \node (B) at (0,1) {B};
                \node (C) at (-1,-1) {C};
                \node (D) at (1,-1) {D};
                \node (E) at (2,1) {E};
                \draw [->] (A) -- (B);
                \draw [->] (B) -- (C);
                \draw [->] (C) -- (A);
                \draw [->] (B) -- (E);
                \draw [->] (E) to [out=90,in=0,looseness=6] (E);
                \draw [->] (D) -- (E);
            \end{tikzpicture}
            \caption{Grafo Dirigido} \label{Fig_2}
        \end{figure}

        Los grafos se usan para representar redes de comunicación, organizaciones de datos y flujos de computación. La primera persona que habló de grafos fue Leonhard Euler resolviendo el problema de los siete puentes de Königsberg. En este problema surgió lo que hoy es conocido como la \textbf{Fórmula de Euler}, la cual relaciona el número de aristas, vértices y caras de un poliedro convéxo.\\

        Uno de los problemas más clásicos en teoría de grafos fue el problema de los cuatro colores:

        \begin{center}
            \textit{¿Es cierto que cualquier mapa dibujado en el plano puede colorearse con 4 colores de tal forma que cualquieras dos regiones que tengan una frontera común tengan diferentes colores?}
        \end{center}
    % section introducción (end)
    \section{Definiciones Básicas} % (fold)
    \label{sec:definiciones_básicas}
        \subsection{Orden y medida} % (fold)
        \label{sub:orden_y_medida}
            El Orden de un grafo es el número de vértices de un grafo $(|V|)$. La medida de un grafo es el número de aristas o flechas $(|E|)$
        % subsection orden_y_tamaño (end)
        \subsection{Valencia y Grado} % (fold)
        \label{sub:valencia_y_grado}
            El grado o valencia de un vértice es el número de aristas llegando o saliendo de él. Si una arista une un vértice consigo mismo cuenta 2 veces.\\

            El in-grado (\textit{in-degree originalmente}) es el número de aristas que llegan al vértices. El out-grado (\textit{out-degree originalmente}) es el número de aristas saliendo del vértice. Estos valores solo se pueden cálcular en un grafo dirigido.
        % subsection valencia_y_grado (end)
        \subsection{Vértice Hoja y Vértice Rama} % (fold)
        \label{sub:vértice_hoja}
            Un vértice hoja, es un vértice que posee una única arista. También pueden ser llamados terminales.\\
            Un vértice rama, es aquel vértice que está conectado por más de dos aristas.
            \begin{center}
                \textit{\textbf{NOTA:} Si un vértice está unido por dos aristas, una a otro vértice y otra a si mismo, en un grafo dirigido formalmente se considera rama, pero ya que muchas veces se toma solo la valencia de entrada no sería rama.}
            \end{center}

        % subsection vértice_hoja (end)
        \subsection{Camino y Bucles} % (fold)
        \label{sub:camino_y_bucles}
            El camino de un grafo es la secuencia de aristas conectadas linealmente. En el grafo dirigido, el final de una arista debe ser el inicio de la siguiente. La longitud de un camino es el número de aristas que contiene. 

            Un bucle o circuito es un camino cerrado. Eso implica que el final de la última arista es el inicio de la primera.
        % subsection camino_y_bucles (end)
    % section definiciones_básicas (end)
    \section{Conectividad de un grafo} % (fold)
    \label{sec:conectividad_de_un_grafo}
        \subsection{Conectividad de un grafo no dirigido} % (fold)
        \label{sub:conectividad_de_un_grafo_no_dirigido}
            Un grafo no dirigido está \textbf{conexo} si existe un camino entre cualquier pareja de vértices. Un \textbf{componente conexo} en un subgrafo en el que todos los puntos están conectados entre sí. En el ejemplo que se muestra a continuación, el grafo es un grafo desconectado con 2 componentes conexos, el primero formado por los nodos 1,2,3,4,5 y el segundo formado por los nodos 7,8,9,10\\
            \begin{center}
                \begin{tikzpicture}
                    \tikzstyle{every node}=[draw,shape=circle];
                    \node (3) at (-1,1) {3};
                    \node (2) at (1,1) {2};
                    \node (1) at (3,2) {1};
                    \node (5) at (1,3) {5};
                    \node (4) at (-1,3) {4};
                    \node (6) at (-3,3) {6};
                    \node (7) at (-3,1) {7};
                    \node (9) at (-1,-1) {9};
                    \node (8) at (-3,-3) {8};
                    \node (10) at (1,-3) {10};
                    \draw (2) -- (3);
                    \draw (3) -- (4);
                    \draw (4) -- (5);
                    \draw (5) -- (2);
                    \draw (5) -- (1);
                    \draw (2) -- (1);
                    \draw (6) -- (4);
                    \draw (7) -- (9);
                    \draw (7) -- (8);
                    \draw (8) -- (9);
                    \draw (9) -- (10);
                    \draw (8) -- (10);
                \end{tikzpicture}
            \end{center}
            
        % subsection conectividad_de_un_grafo_no_dirigido (end)

        \subsection{Conectividad de un grafo dirigido} % (fold)
        \label{sub:conectividad_de_un_grafo_dirigido}
            Se dice que un grafo dirigido está conectado de forma \textbf{débil} cuando está conectado como un grafo no dirigido.

            Un grafo dirigido esta \textbf{semiconectado} cuando para dos vértices cualesquiera $(u,v)$ contiene un camino de $u$ a $v$ \textbf{o} de $v$ a $u$.

            Un grafo dirigido está conectado de forma \textbf{fuerte} si existen ambos caminos en el grafo semiconectado. Un ejemplo de un grafo dirigido con 3 componentes conectados de forma fuerte es el siguiente:\\
            \begin{center}
                \begin{tikzpicture}
                    \tikzstyle{every node}=[draw,shape=circle];
                    \node (1) at (0,1) {1};
                    \node (0) at (-2,1) {0};
                    \node (2) at (-2,-1) {2};
                    \node (3) at (2,1) {3};
                    \node (4) at (2,-1) {4};
                    \draw [->] (0) -- (1);
                    \draw [->] (1) -- (2);
                    \draw [->] (2) -- (0);
                    \draw [->] (1) -- (3);
                    \draw [->] (3) -- (4);
                \end{tikzpicture}
            \end{center}
            Los 3 componentes fuertes corresponderían al formado por 0,1 y 2, el segundo formado unicamente por el 3 y el tercero formado unicamente por el 4.
        % subsection conectividad_de_un_grafo_dirigido (end)
    % section conectividad_de_un_grafo (end)
    \section{Modelos de Memoria} % (fold)
    \label{sec:modelos_de_memoria}
        \subsection{Lista de Adyacencia} % (fold)
        \label{sub:lista_de_adyacencia}
            Los vértices estań organizados como estructuras y cada vértice guarda una lista de vértices adyacentes (de ahí el nombre de lista de adyacencia). Esta estructura de datos permite almacenar datos adicionales sobre los vértices.

            Una estructura en C se define utilizando el comando \textit{struct}
        % subsection representación_en_lista_lista_de_adyacencia (end)
        \subsection{Lista de Incidencia} % (fold)
        \label{sub:lista_de_incidencia}
            Tanto los vértices como aristas están almacenadas como estructuras. Cada arista guarda los vértices que incide, y de forma opcional los vértices pueden guardar las aristas incidentes. Esto permite almacenar información adicional de tanto vértices como de aristas.
        % subsection representación_en_lista_lista_de_incidencia (end)
        \subsection{Matriz de Adyacencia} % (fold)
        \label{sub:matriz_de_adyacencia}
            Es una matriz bidimensional en la que las columnas representan los vértices de inicio y las finals los vértices del final de una arista. La entrada i,j en la matriz, correspondería al número de flechas que empiezan en i y terminan en j. En un grafo no dirigido, esta matriz es simétrica.\\

            \begin{center}
                $\begin{pmatrix} 
                    0 & 1 & 0 & 0 & 0\\
                    0 & 0 & 1 & 0 & 1\\
                    1 & 0 & 0 & 0 & 0\\
                    0 & 0 & 0 & 0 & 1\\
                    0 & 0 & 0 & 0 & 1    
                \end{pmatrix}$ 
            \end{center}
            Esta matriz representa los datos del grafo dirigido representado en la Figura \ref{Fig_2}.
        % subsection matriz_de_adyacencia (end)
        \subsection{Matriz de Incidencia} % (fold)
        \label{sub:matriz_de_incidencia}
            Es una matriz bidimensional formada por datos \textit{Bool} (True y False) en el que las filas representan los vértices y las columnas representan las aristas. Sus entradas indican si el vértice de la fila y la arista de la columna son incidentes. Para grafos dirigidos:
            \begin{itemize}
                \item +1 indica que el vértice es el origen de la flecha
                \item -1 indica que el vértice es el final de la flecha
            \end{itemize}
            \begin{center}
                $\begin{pmatrix} 
                    1 & 0 & -1 & 0 & 0\\
                    -1 & 1 & 0 & 1 & 0\\
                    0 & -1 & 1 & 0 & 0\\
                    0 & 0 & 0 & 0 & 1\\
                    0 & 0 & 0 & -1 & -1    
                \end{pmatrix}$ 
            \end{center}
            Esta matriz también representan el grafo digido de la Figura \ref{Fig_2}. Sin embargo, en este caso no se puede representar la flecha que sale del nodo 5 y vuelve a entrar.         
        % subsection matriz_de_incidencia (end)
    % section modelos_de_memoria (end)
    \section{Árboles y árboels con raiz} % (fold)
    \label{sec:árboles_y_árboels_con_raiz}
        \subsection{Árboles} % (fold)
        \label{sub:árboles}
            Un \textbf{árbol} es un grafo conexo sin bucles. Puede también tomarse como un arbol unicamente arconexo, es decir, para llegar de un nodo a otro del vértice existe un único camino posible. Los árboles presentan una serie de propiedades:
            \begin{itemize}
                \item Si se añade una arista de forma aleatoria se crea un bucle.
                \item Si se elimina cualquier arista el árbol se vuelve disconexo.
                \item Un árbol con $n$ vértices tiene exactamente $n-1$ (La caracterísitca de Euler es igual a 1)
            \end{itemize}
        % subsection árboles (end)
        \subsection{Árboles con raiz} % (fold)
        \label{sub:árboles_con_raiz}
            Un árbol con raiz es un árbol en el que un vértice ha sido definido como \textbf{raiz} o \textbf{nodo base}. Un ejemplo de un árbol con raiz podría ser el siguiente:
            \begin{center}
                \begin{tikzpicture}
                    \tikzstyle{node 1}=[color=red];
                    \tikzstyle{every node}=[draw,shape=circle,distance=30mm];
                    \node[fill=red, fill opacity = 0.8] (1) [above right of=2] {1};
                    \node (2) [below left of=1] {2};
                    \node (5) [below right of=2] {5};
                    \node (3) [below right of=1] {3};
                    \node (4) [below left of=2] {4};
                    \node (6) [below right of=3] {6};
                    \node (7) [below left of=5] {7};
                    \node (8) [below right of=5] {8};
                    \node (9) [below of=6] {9};
                    \draw[->] (1) -- (2);
                    \draw[->] (1) -- (3);
                    \draw[->] (2) -- (4);
                    \draw[->] (2) -- (5);
                    \draw[->] (3) -- (6);
                    \draw[->] (5) -- (7);
                    \draw[->] (5) -- (8);
                    \draw[->] (6) -- (9);

                \end{tikzpicture}
            \end{center}
            En un árbol con raiz, los vértices hoja y rama son vértices hoja y rama comunes excepto el vértice raiz. Es importante tener en cuenta que la valencia de estos vértices no depende del nodo raiz, es decir, son indpendientes de él. La \textbf{profundidad} de un vértice se define como la distancia desde el nodo raiz hasta este vértice. La profundidad si depende del nodo raiz. Esta distancia se mide como la distancia del único camino que los une. Por ende, la profundidad de un nodo consigo mismo es 0, luego la profundidad del nodo raiz es 0.\\

            La profundidad de un árbol con raiz se considera la profundidad más larga de los vértices (esto depende de la raiz que se tome).
            \subsubsection{Nodos padre e hijo} % (fold)
            \label{subsub:nodos_padre_e_hijo}
                Si tenemos un árbol con raíz y tomamos un nodo $v$ de profundidad $p>0$, el padre de $v$ es el único nodo conectado a $v$ que presenta una profundidad de $p-1$.Un nodo hijo de $u$ (siendo $u$ un nodo de profundidad $p\ge0$) es aquel nodo conectado a u que posea una profundidad de $p+1$.\\

                Un árbol $n-ario$ es un árbol con raiz en el que cada nodo presenta $n$ hijos.
            % subsubsection nodos_padre_e_hijo (end)
        % subsection árboles_con_raiz (end)
        \subsection{Tree traversal} % (fold)
        \label{sub:tree_traversal}
            \subsection{Depth-first search: pre-order} % (fold)
            \label{sub:depth_first_search_pre_order}
                Es un algoritmo de búsqueda en el que primero se visita el nodo en el que estés y a continuación el hijo de la izquierda del nodo en el que te encuentres. Si ese nodo tiene hijos se repite este proceso con ese nodo, sino se pasa al siguiente hijo desde la izquierda. El objetivo de esto es que, después de haber visitado el nodo en el que estés, si se puede aumentar la profundidad en la que estás lo hagas, y si no es posible retrocedas hasta poder acceder a un camino nuevo y continuar con este proceso.
            % subsection depth_first_search_pre_order (end)
            \subsubsection{Depth-first search: in-order} % (fold)
            \label{subsub:depth_first_search_in_order}
                Este algoritmo primero se mueve hacia el hijo más hacia la izquierda de todos los nodos. Tras esto lo visita, se desplaza hacia su padre directo, lo visita y repite el proceso por la derecha. Si el padre directo no presenta más caminos, se sigue reduciendo la profundidad hasta encontrar un padre con un camino disponible. 
            % subsubsection depth_first_search_in_order (end)
            \subsubsection{Breadth-first search} % (fold)
            \label{subsub:breadth_first_search}
                En este algoritmo, se recorren los nodos del arbol nivel a nivel empezando por la izquierda.Si tuviesemos el siguiente grafo:\\
                \begin{center}
                    \begin{tikzpicture}
                        \tikzstyle{node F}=[color=red];
                        \tikzstyle{every node}=[draw,shape=circle,distance=10mm];
                        \node[fill=red, fill opacity = 0.8] (F) at (0,0) {F};
                        \node (F) at (0,0) {F};
                        \node (B) at (-1,-1) {B};
                        \node (G) at (1,-1) {G};
                        \node (A) at (-1.5,-2) {A};
                        \node (D) at (-0.5,-2) {D};
                        \node (I) at (1.5,-2) {I};
                        \node (C) at (-1,-3) {C};
                        \node (E) at (0,-3) {E};
                        \node (H) at (1,-3) {H};
                        \draw[->] (F) -- (B);
                        \draw[->] (F) -- (G);
                        \draw[->] (B) -- (A);
                        \draw[->] (B) -- (D);
                        \draw[->] (G) -- (I);
                        \draw[->] (D) -- (C);
                        \draw[->] (D) -- (E);
                        \draw[->] (I) -- (H);
                    \end{tikzpicture}
                \end{center}
                
            % subsubsection breadth_first_search (end)
        % subsection tree_traversal (end)
        \subsection{Grafos con Raiz} % (fold)
        \label{sub:grafos_con_raiz}
            Un grafo con raiz, también llamado, grafo de flujo o grafo puntuado, es un grafo en el que se ha indicado un nodo como raiz. En estos grafos, un nodo hoja corresponde a aquellos nodos con valencia 1 diferente de la raiz. Un nodo rama corresponde a todo vértice con una valencia mayor a 2 sin contar la raiz. Es preciso indicar que al indicar la valencia de los nodos no se contará la raiz, pues este nodo abandona su función de rama y hoja para trabajar como raiz. Una distinción fundamental de los grafos con raiz frente a los árboles con raíz es que puede existir más de un camino para llegar a un nodo.\\

            \textbf{Profundidad:} La profundidad de un nodo es la distancia mínima desde la raiz a un nodo. La distancia mínima entre dos nodos es el tamaño del camino más pequeño entre estos dos. La distancia de un nodo a si mismo es 0. Si no existe un camino entre los dos nodos, su distancia es infinito. La profundidad del grafo es la profundidad máxima de todos los nodos.
        % subsection grafos_con_raiz (end)
        \subsection{Shortest path algorithm} % (fold)
        \label{sub:shortest_path_algorithm}
            El breadth-first search algorithm encuentra uno de los caminos más cortos entre la raiz del grafo y un nodo dado. Esta no es la misma forma que calcular la distancia entre dos nodos dados. Este algoritmo devuelve lo que se denomina un minimal spanning tree.\\

            Un \textbf{spanning tree} de un grafo conectado es un subset de aristas del grafo que conecta todos sus vértices y es un arbol. \textbf{Un minimal spanning} tree de un arbol conectado es un spanning tree tal que cualquier camino $\alpha$ en el spanning tree empezando en la raiz tiene una distancia minima entre todos los caminos en el grafo empezando en la raiz y terminando en el mismo vértice que $\alpha$.

            No hay que confundirlo con el algoritmo \textbf{depth-first search}. Este algoritmo recorre correctamente el grafo en profundidad, pero no computa nien la profundidad del nodo, de tal forma que a pesar de generar un spanning tree, no será minimal.
        % subsection shortest_path_algorithm (end)
    % section árboles_y_árboles_con_raiz (end)
\end{document}